
<!DOCTYPE html>
<html lang="zn-CH" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Java基础 - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="1.变量的概念
概念
变量相当于内存中一个数据存储空间的表示，可以把变量看作是一个房间的门牌号，通过门牌号可以找到房间，通过变量名可以访问到变量的值

基本使用步骤

声明变量
int a;

赋值,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://cyclecod.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">Java基础</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">Java基础</h1>
        <div class="stuff">
            <span>六月 26, 2021</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="1-变量的概念"><a href="#1-变量的概念" class="headerlink" title="1.变量的概念"></a>1.变量的概念</h1><ol>
<li><p>概念</p>
<p>变量相当于内存中一个数据存储空间的表示，可以把变量看作是一个房间的门牌号，通过门牌号可以找到房间，通过变量名可以访问到变量的值</p>
</li>
<li><p>基本使用步骤</p>
<ol>
<li><p>声明变量</p>
<p>int a;</p>
</li>
<li><p>赋值</p>
<p>a = 10;</p>
</li>
<li><p>使用System.out.println(a)输出</p>
</li>
<li><p>也可以一步到位（int a = 10;）</p>
</li>
</ol>
</li>
<li><p>变量使用注意事项</p>
<ol>
<li>变量表示内存中的一个存储区域</li>
<li>该区域有自己的名称和类型</li>
<li>该区域的数据可以在同一类型范围内不断的变化</li>
<li>变量在同一个作用域内不能重名</li>
</ol>
</li>
</ol>
<h1 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h1><ol>
<li>Java数据类型分为两大类   基本数据类型、引用类型</li>
<li>基本数据类型有8种 数值型[btye[ 1 ]、short[ 2 ]、int[ 4 ]、long[ 8 ]、float[ 4 ]、double[ 8 ] ] char[ 2 ]、boolean[ 1 ]</li>
<li>引用类型：类[ class ]，接口[ interface ]，数组[ {} ]</li>
<li>浮点数使用陷阱：2.7和8.1 / 3比较不相等</li>
</ol>
<h1 id="3-基本数据类型转换"><a href="#3-基本数据类型转换" class="headerlink" title="3.基本数据类型转换"></a>3.基本数据类型转换</h1><ol>
<li><p>有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算</p>
</li>
<li><p>当我们把精度（容量）大的数据类型赋值给精度容量小的数值类型时，就会报错，反之就会自动类型转换</p>
</li>
<li><p>（byte、short）和char之间不会相互自动转化</p>
</li>
<li><p>byte、short、char三者之间可以进行计算，计算时首先转化为int类型</p>
</li>
<li><p>自动提升原则：表达式结果的类型自动提升为操作数中最大的类型</p>
</li>
<li><p>基本数据类型和String类型的转换：</p>
<ol>
<li><p>基本数据类型转String</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">String s = a + <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>String类型转基本数据类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;123&quot;</span></span><br><span class="line">Integer.parseInt(s);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="4-标识符命名规范"><a href="#4-标识符命名规范" class="headerlink" title="4.标识符命名规范"></a>4.标识符命名规范</h1><ol>
<li>包名：多单词组成时所有字母都小写</li>
<li>类名，接口名：多单词组成时所有单词的首字母大写</li>
<li>变量名、方法名：多单词组成时，第一个单词首字母小写，其余单词首字母大写</li>
<li>常量名：所有字母都大写。多单词时每个单词用下划线连接</li>
</ol>
<h1 id="5-类与对象"><a href="#5-类与对象" class="headerlink" title="5.类与对象"></a>5.类与对象</h1><ol>
<li>类和对象的内存分配机制<ol>
<li>栈：一般存放基本数据类型（局部变量）</li>
<li>堆：存放对象（Cat cat 、 数组等）</li>
<li>方法区：常量池（常量，比如字符串），类加载信息</li>
</ol>
</li>
</ol>
<h1 id="6-递归"><a href="#6-递归" class="headerlink" title="6.递归"></a>6.递归</h1><p>递归的重要规则</p>
<ol>
<li>执行一个方法时，就创建一个新的受保护的独立空间（栈空间）</li>
<li>方法的局部变量是独立的，不会相互影响，比如n变量</li>
<li>如果方法中使用的是引用数据类型（数组、对象），就会共享该引用类型的数据</li>
<li>递归必须向退出递归的条件逼近，否则就是无线递归，出现StackOverflowError</li>
<li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕 </li>
</ol>
<h1 id="7-可变参数"><a href="#7-可变参数" class="headerlink" title="7.可变参数"></a>7.可变参数</h1><p>基本概念</p>
<ol>
<li>Java允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法，就可以通过可变参数实现</li>
<li>基本语法：访问修饰符 返回值类型 方法名（数据类型…形参名）</li>
<li>可变参数的注意事项和使用细节<ol>
<li>可变参数的实参可以时0个或任意个多</li>
<li>可变参数的实参可以为数组</li>
<li>可变参数的本质就是数组</li>
<li>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后</li>
<li>一个形参列表中只能出现一个可变参数</li>
</ol>
</li>
</ol>
<h1 id="8-构造器-构造方法"><a href="#8-构造器-构造方法" class="headerlink" title="8.构造器/构造方法"></a>8.构造器/构造方法</h1><p>基本语法：[修饰符] 方法名 （形参列表）</p>
<ol>
<li>构造器的修饰符可以默认</li>
<li>一个类可以有多个构造器</li>
<li>构造器没有返回值</li>
<li>方法名必须和类名相同</li>
<li>参数列表和成员方法一样的规则</li>
<li>构造器是完成对象的初始化，并不是创建对象</li>
<li>构造器的调用系统完成</li>
<li>如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造方法</li>
<li>一旦定义了自己的构造器，默认的构造器就被覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下</li>
</ol>
<h1 id="9-面向对象的三大特征"><a href="#9-面向对象的三大特征" class="headerlink" title="9.面向对象的三大特征"></a>9.面向对象的三大特征</h1><ol>
<li>封装<ol>
<li>封装就是把抽象出来的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[方法]，才能对数据进行操作</li>
</ol>
</li>
<li>继承<ol>
<li>继承可以解决代码复用，让我们的编程更加靠近人类思维，当多个类存在相同的属性（变量）和方法时，可以从这些类中抽出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要extends来声明继承父类即可</li>
<li>一个子类只能继承一个父类，一个父类可以有多个子类</li>
<li>子类必须调用父类的构造器，完成父类的初始化</li>
<li>当创建子类对象时，不管使用子类的那个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，在必须在子类的构造器中用super去指定使用父类的那个构造器来完成父类的初始化工作，否则，编译不通过</li>
<li>super在使用时，需要放在构造器的第一行</li>
<li>super()和this()都只能放在构造器第一行，所以这两个方法不能共存在一个构造器</li>
</ol>
</li>
<li>多态<ol>
<li>多态的具体体现<ol>
<li>一个对象的编译类型和运行类型可以不一致</li>
<li>编译类型在定义对象时就确定了，不能改变</li>
<li>运行类型时可以变化的</li>
<li>编译类型看定义是 = 号的左边，运行类型看 = 号的右边</li>
</ol>
</li>
<li>多态的注意事项和细节讨论<ol>
<li>多态的前提是：两个类具有继承关系</li>
<li>多态的向上转型</li>
<li>本质：父类的引用指向了子类对象</li>
<li>语法：父类类型  引用名  =  new  子类类型()</li>
<li>特点：编译类型看左边，运行类型看右边，可以调用父类中的所有成员（需遵守访问权限）不能调用子类中的特有成员，最终运行效果看子类的具体实现</li>
<li>多态的向下转型<ol>
<li>语法：子类类型  引用名  =  （子类类型）父类引用</li>
<li>只能强转父类的引用，不能强转父类的对象</li>
<li>要求父类的引用必须指向的是当前目标类型的对象</li>
<li>当向下转型后，可以调用子类类型中所有的成员</li>
</ol>
</li>
<li>属性没有重写之说，属性的值看编译类型</li>
<li>instanceOf比较操作符，用于判断对象的运行类型是否为XX类型或XX类型的子类型</li>
<li>Java的动态绑定机制<ol>
<li>当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定</li>
<li>当调用对象属性时，没有动态绑定机制，那里声明，那里使用</li>
</ol>
</li>
<li>类变量和类方法<ol>
<li>什么是类变量：类变量也叫做静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量</li>
<li>如何定义类变量：访问修饰符 static 数据类型 变量名;访问修饰符可以不要</li>
<li>类变量是随着类的加载而创建，所以即使没有创建对象实例也可以访问</li>
<li>如何访问类变量：类名.类变量名或者，对象名.类变量名（静态变量的访问修饰符和访问权限和普通属性是一样的）</li>
<li>类变量使用注意事项和细节讨论<ol>
<li>什么时候需要有类变量：当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）</li>
<li>类变量和实例变量的区别：类变量是该类的所有对象共享的，而实例变量是每个对象独享的</li>
<li>加上static关键字成为类变量或静态变量，否则称为实例变量/普通变量/非静态变量</li>
</ol>
</li>
</ol>
</li>
<li>解释main方法的形式：public static void main(String[] args){}<ol>
<li>main方法是虚拟机调用的</li>
<li>Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public</li>
<li>Java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static</li>
<li>该方法接收String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数</li>
</ol>
</li>
<li>代码块<ol>
<li>代码块又称初始化块，属于类中的成员，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来</li>
<li>没有方法名，没有返回值类型，没有参数，只有方法体，而且不同通过对象显式调用，而是加载类时，或创建对象时隐式调用</li>
<li>注意：<ol>
<li>修饰符要写的话只能写static</li>
<li>代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的叫普通代码块或非静态代码块</li>
<li>逻辑语句可以为任何逻辑语句（输入输出，方法调用，循环，判断等）</li>
</ol>
</li>
<li>代码块使用注意事项和细节讨论<ol>
<li>static代码块也叫静态代码块，作用就是对类进行初始化，而且随着类的加载而执行，且只会执行一次，非静态代码块每创建一个对象就会执行一次</li>
<li>类什么时候被加载<ol>
<li>创建对象实例时</li>
<li>创建子类对象实例，父类也会被加载</li>
<li>使用类的静态成员时</li>
</ol>
</li>
<li>普通代码块在创建对象实例时，会被隐式的调用，被创建一次就会调用一次，如果只是使用类的静态成员时，普通代码块并不会执行</li>
<li>创建一个对象时，在一个类中，调用顺序是<ol>
<li>调用静态代码块和静态属性初始化（静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）</li>
<li>调用普通代码块和普通属性的初始化（普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）</li>
<li>调用构造方法</li>
</ol>
</li>
<li>构造方法（构造器）的最前面其实隐藏了super()和调用普通代码块；静态相关的代码块和属性初始化，在类加载时，就执行完毕，因此是优先于构造器和普通代码块执行的</li>
<li>静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r='git@github.com:cyclecod/cyclecod.github.io.git'
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%8F%98%E9%87%8F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">1.变量的概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">2.数据类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">3.基本数据类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">4.</span> <span class="toc-text">4.标识符命名规范</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.</span> <span class="toc-text">5.类与对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E9%80%92%E5%BD%92"><span class="toc-number">6.</span> <span class="toc-text">6.递归</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">7.可变参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E6%9E%84%E9%80%A0%E5%99%A8-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">8.构造器&#x2F;构造方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">9.</span> <span class="toc-text">9.面向对象的三大特征</span></a></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
